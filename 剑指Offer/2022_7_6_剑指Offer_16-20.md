# 数值的整数次方

[剑指 Offer 16. 数值的整数次方 - 力扣（LeetCode）](https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/)

模拟pow的实现

比如求3^1000；1000~D~==001111101000~B~

> 一个一个乘效率太低了，时间按复杂度是O(N),而且还会超时，~~你问我怎么知道的~~

利用快速幂,时间复杂度是O(logn)。

以3^1000^ ,1000=512 +256+128+64 +32+8。

所以3^1000^=3^512^ · 3^256^ · 3^128^· 3^64^  3~32~ ·3^8^  。其中512，256，128等这些数字对应的是 001111101000~B~ 中为1的位置。

所以实现就很清楚了，找到指数的二进制中为1的那几位，将其累乘即可。又因为这些都是二的倍数所以可以通过1，2，4，8，16……这样的办法快速拿到。比如直到了2^2^ 就可以直到2^4^ ，从而知道了2^8^,这样就可以一直递推下去，而且是以指数的方式增长效率很高

## 非递归

```c++
class Solution {
public:
    double myPow(double x, int n) {
        if(x==1) return 1;
        if(x==0) return 0;
        long long times=n;//n可能是int范围内最小的负数，如果不这样处理，将n转成正数的时候就可能溢出
        double base=x;
        if(times<0)
        {
            times=-times;
            base=1/base;
        }
        double res=1;
        while(times)
        {
            if(times&1)//相当于times%2==1
            {
                res*=base;
            }
            base*=base;
            times>>=1;//相当于times/=2，但是位运算更快
        }
        return res;
    }
};
```

## 递归

```c++
class Solution {
public:
     double quickMul(double x, long long n)
     {
         if(n==0)
         {
             return 1;
         }
         double ans=quickMul(x,n>>1);//算出x的n/2次方
         return n&1?ans*ans*x:ans*ans;
     }
    
    double myPow(double x, int n) {
        long long times=n;
        if(times<0)
        {
            return 1/quickMul(x,-times);
        }
        return quickMul(x,times);
    }
};
```

# 打印从1到最大的n位数

[剑指 Offer 17. 打印从1到最大的n位数 - 力扣（LeetCode）](https://leetcode.cn/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/)

需要考虑大数，力扣上面是简单题因为不用考虑大数，但是书上是要求考虑大数的。

铺垫：全排列+递归生成数字序列，以打印的形式打印出来。

递归思想：先固定第一位，再去固定第二位....（力扣大佬题解里的图很清晰表述了这个过程）

```cpp
int start;
int nine = 0;
void dfs(vector<int>& nums,int x,int length)//nine和start的引入是为了去除前导0
{
	if (x == length )
	{
		for (int i=start;i<nums.size();i++)
		{
			cout << nums[i];
		}
		cout << endl;
		if (nine + start == length)
		{
			start--; 
		}
		return;
	}
	for (int i = 0; i <= 9; i++)
	{
		if (i == 9)
		{
			nine++;
		}
		nums[x] = i;
		dfs(nums, x + 1, length);
	}
	nine--;//回溯 保证每一层的9的个数不会累加，而是这一层结束立马变回原样，nine变为2是在099时。
}
#define N 4
int main()
{
	vector<int>nums;
	nums.resize(N);
	start = N - 1;
	dfs(nums, 0, N);
	return 0;
}

```

改一下上面的代码提交力扣

```cpp
class Solution {
public:
    vector<int> printNumbers(int n) {
        vector<int>nums(n);
        dfs(nums,0,n);
        return ret;
    }
    vector<int>ret;
    int start;
    int nine = 0;
    void dfs(vector<int>& nums, int x, int length)//nine和start的引入是为了去除前导0
    {
        if (x == length)
        {
            string res;
            for (int i = start; i < nums.size(); i++)
            {
                res+=(nums[i]+'0');
            }
            int x=stoi(res);//这里最好直接转成整数判断去掉0，用字符串可能出现判断“0”和“00”这样的
            //我的vs上判断的字符串if(res!="0")可以去掉0，但在力扣上并不行，所以转成整数判断了
            if(x)
            {
                 ret.push_back(x);
            }      
            if (nine + start == length)
            {
                start--;
            }
            return;
        }
        for (int i = 0; i <= 9; i++)
        {
            if (i == 9)
            {
                nine++;
            }
            nums[x] = i;
            dfs(nums, x + 1, length);//固定第x+1位。
        }
        nine--;//回溯 保证每一层的9的个数不会累加，而是这一层结束立马变回原样，nine变为2是在099时。
    }
};
```















